---
title: Flag
description: What is Flags
---

:::note

need rewrite this article with english

:::

## Flags

### What is Flag, and Option?

Inside `cmdr.v2`, terms `Flag` and `Option` are used confusingly, and constantly. But, these two terms are different in fact.

A `Flag`, means that an object created via the interfaces like `app.Flg()`/`builder.Flg()`, which will be used for interpreting an cmdline option, and there is also a coresponding `Option` item in `Option Store` that is mapping to it.

A `Option` item, means that a key-value pair in `Option Store`. For instance, `“app.debug” => true` is a kv pair entry. The hierarchical layout of its yaml representation is,

```yaml
app:
  debug: true
```

In the most scenes, we would like use `Option` to represent a key-value pair identified by `keyPath`, whatever it is a `Flag` exactly, or not.

### Integrated with `Option Store`

We knew `Option Store` is a in-memory config manager for hierarchical key-value pairs dataset identified by `dottedPath`/`keyPath`. And, an `Option` can be associated with a `Flag`, or not. But there is always an `Option` binded to a `Flag`.

For the top level flag `--debug`, the store entry associated with it is `app.cmd.debug`, since `app.cmd` is a hard-coded prefix for command line options.

For those flags of subcmds, such as `--cacert` under subcmd `cert / create`, the entry dotted path would be `app.cmd.cert.create.cacert`.

#### `cmd.Store()` vs `cmd.Set()`

Programmatically, you can code with `app.Store()/app.Set()`.

The `cmd.Store()` returns a subset of app's whole Store, which have a root key pointed to key path `app.cmd.jump.to`. That means, `cmd.Store().MustBool("full")` can read and write the state of a command line flag `--full`.

The `cmd.Set()` returns the app's whole Store, which equals to `app.Set()`，So you need a `cmd.Set().MustBool("app.cmd.jump.to.full")` to access the state of `--full`. Another way is,

```go
set := cmd.Set().WithPrefix(cli.DottedPathToCommandOrFlag)
println(set.MustBool("full"))
assert.Equal(set, cmd.Store())
```

The similar call to `app.Store()` will get a subtree pointed to `app.cmd`, which stores the values of all of command-line flags. So `app.Store().MustBool("jump.to.full")` can query the same key above.

> For a short and concise calling statement, it's useful by using `GetXXX`/`MustXXX` on the object of `cmd.Store()`/`app.Store()`.

The prefix `app.cmd` is used for serializing the `Option Store`, such as YAML, TOML, etc.. The notable point is `app` will be stripped when you're really serializing it. So a key `app.some.path.debug` will be stored as `some.path.debug` in a YAML file:

```yaml
some:
  path:
    debug: false
```

As a sample, here is a Store's YAML file content:

```yaml
# The common prefix `app` will be stripped in serializing to a file.
logging:
  file: /var/log/app/stdout.log
server:
  port: 3000
  host: 0.0.0.0
  tls: {}
  domains: []
# The following entries are visible only in memory.
# We list them for showing the completely Store-tree
# more clearly.
cmd:
  debug: false # 对应于 `--debug`
  verbose: false # 对应于 `--verbose`
```

#### `keyPath`/`dottedPath`

`keyPath`/`dottedPath`/`dottedKeyPath` is a exclusive term specially for `Option Store`, which provides an anchor to any entries in the `Store` by the form `prefix.subcmds...flag`.

For an intance, a dottedPath `app.cmd.cert.create.cacert` has `app.cmd` as a special prefix for command-line flags, and `cert.create` is subcommands `cert` and its child `create`, and `cacert` is the long title of a flag, which belongs to subcmds `cert.create`.

The flag `cacert` can be specified by `--cacert` from command-line.

### Long Flag, Short and Alias

The term `Long Flag` is required for a command-line flag. It is the unique identifier in `cmdr` system.

A `Long Flag` has prefix `--` in the command-line. For example, `--cacert` is a flag of subcmds `cert.create`:

```bash
$ app cert create --cacert "./ca.cer"
```

The `Short Flag` can be attached to a command-line flag. It uses prefix `-` in the command-line. It is a shortcut to a flag.

Under `cmdr.v2` system, multiple short flags can be attached with one flag by using call like `b.Flg(longTitle, shortTitle...).ExtraShorts(...)`.

Short flag is constantly a single char in POSIX standard. So we can use `-v` as the shortcut to `--verbose` flag.

But in `cmdr` system (both v1 and v2), a short flag can be a string with any length. As a sample, `-ap` has short title `ap`, shortcut to `--extra-files`, this is legal too.

Golang `flags` uses a wired form different than POSIX standard, which has no short or long flag, all flags have the single hyphen char as its leading prefix. That is why in a golang app `-port` will be used for setting the listening port number rather than `--port`.

> `cmdr` is a POSIX-compliant command-line argument parser. So we recommend using `-p` and `--port` to specify port number. But you can still make a golang flag like app by specifying a short flag with title name `port`, this is legal option.

By using the builder interface, `Flg(longTitle, shortTitle, ...)` allows more alias titles associated with a flag. The alias titles are equavalent to long flag, with the leading double hyphen chars `--`.

As a sample, `b.Flg("version", "V", "ver")` defines a version flag with both long, short and alias titles. So the following command-line inputs are avaliable:

```bash
$ app --version
$ app -V
$ app --ver
```

Totally you can always organize your command and flag system in a freestanding form. Keep it concise. Too much command depthes and too much more flags are not kindly enough to end-user.

### Compat short flags

Multiple short flags can be compated into one leading hyphen char `-`, this is POSIX-compliant. The compat form is equavalent to the split form:

```bash
-azro === -a -z -r -o === -a -zr -o
```

### Default Value

You can specify the default value to a flag, with different types.

`b.Flg("count", "c").Default(3)` defined its default value is `int(3)`.

The primitive value, including integer, float, complex, boolean, or string, time, duration, slice can be specified as the default value of a flag.

So `b.Flg("interval", "i").Default(3*time.Second)` defined a time duration value `3s`. End user can input the new value with Golang literal convension, for a example:：

```bash
$ app -i 8m
```

It specifys a duration value with 8 minutes, which overrides the default value when you defined it.

### Duplicated inputs

In general, duplicated inputs of a flag causes the old value to be overlapped by the new one.

So `app -c 3 -c 4 -c 5` means the final value of `-c` is 5.

The exception is slice value. The duplicated inputs of a flag with default slice value causes the new value to apppend to the old. And, the delimiter char `,` is used for splitting the items in one input string.

This means, as for a flag `b.Flg("add", "a").Default([]string{"a", "b"})`, the input `app -a z,y -a x -a u,v,w` will get the final value `[]string{"z","y","x","u","v","w"}`.

### Input in command-line

cmdr support stripping the quote chars for a flag:

- `--host=localhost`
- `--hostlocalhost`
- `--host localhost`
- `"--hostlocalhost"`
- `'--hostlocalhost'`
- `--host"localhost"`
- `--host'localhost'`
- `--host "localhost"`

and so on.

其中，双引号和单引号在主流的 Shell 环境中被自动去除。但是如果它们没有被 Shell 所删除，则 cmdr 遵照上面的参考格式自动在求值前删除引号。

如果为标志关联了数组值作为默认值，cmdr 将会把多次输入的值合并叠加到一起形成一个最终的数组值。

无论用户如何输入，cmdr 会为标志维护一个命中次数记录，以及命中时用户输入的标志名（是长还是短）。某些情况下你可以参考这些辅助信息来改变相关逻辑。

作为一个范本，cmdr 的内建标志 `--verbose` 的命中次数被预设了如下逻辑：

1. 用户没有输入

   hidden flags/commands 不会显示于帮助屏

2. 输入了一次
   hidden flags/commands 将会显示于帮助屏
3. 输入超过三次
   vendor-hidden flags/commands 将会显示于帮助屏

你也可以再次解释命中次数。例如 `--verbose` 的命中次数被用作一个 1-9 级的等级值，对应于提示信息的多寡。

> 对于一些 cmdr 内建提供的标志，应用程序经常会使用的 verbose, quiet, debug 等等，在 `hedzr/is` 的 `Env` 中同步管理了它们的命中状态，命中次数。
> 参考：
>
> - `is.VerboseModeEnabled()`, `is.GetVerboseLevel()`
> - `is.QuietModeEnabled()`, `is.GetQuietLevel()`
> - `is.NoColorModeEnabled()`, `is.GetNoColorLevel()`
> - `is.DebugMode()`, `is.GetDebugLevel()`
> - `is.TraceMode()`, `is.GetTraceLevel()`

### cmdr 的更多增强 [#enhances]

1. cmdr 的短标志不会被限定在单个字母。

   我们支持多个字母数字符号作为短标志。

   换句话说，你可以令长短标志的界限模糊，从而提供同时兼容于 golang flag 风格和 getopt 风格的标志集合。

   > Golang flag 风格：命令行参数总是单短横线引导的，如：`-host abc -port 9999`
   >
   > getopt 风格：允许单、双短横线引导，分别代表短、长标志，通常短标志使用单个字母或数字，如：`-d -t --retry 3`。
   >
   > cmdr 风格：在完全兼容 getopt 风格的基础上，通过解除单字母短标志限制，使得 cmdr cli app 也能支持 `-host abc` 这样的 golang flag 风格，甚至是 `-host abc --retry 3` 这样的混合风格（wget 采用这样的混合性风格）

2. 在无歧义的情况下，cmdr甚至支持你组合任何短标志。

   所以，`-dr3t` 能够被解释为 `--debug --retry 3 --timeout`。

   cmdr 采取特别的反向回溯算法来解决这个场景下的多级子命令的多级标志的智能匹配。

## Learn More

<Cards>
  <Card title="Required" href="../howto/required-flag" />
  <Card title="Toggle Group" href="../howto/toggle-group-of-flags" />
  <Card title="Head Like" href="../howto/head-like-flag" />
  <Card title="Valid Args" href="../howto/valid-args-flag" />
  <Card title="External Tool" href="../howto/flag-with-external-flag" />
</Cards>
