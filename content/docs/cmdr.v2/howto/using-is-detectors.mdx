---
title: Using is Detectors
description: is.inDeveloping()?
---

## ä»‹ç»

[`hedzr.is`](https://github.com/hedzr/is) æ˜¯ä¸€ä¸ªä»¥ç¯å¢ƒæ£€æµ‹å‡½æ•°ä¸ºä¸»çš„åŸºç¡€æ”¯æŒåº“ã€‚

`is` provides numerous detectors for checking the states of environment (build, executive, ...).

åœ¨ `is` ä¸­æä¾›äº†å¤§é‡ Golang è¿è¡Œç¯å¢ƒæ£€æµ‹å·¥å…·ï¼Œæœ‰çš„ç‹¬ç«‹å·¥ä½œï¼Œæœ‰çš„éœ€è¦é…åˆ go build tags ååŒå·¥ä½œã€‚
æ€»çš„æ¥è¯´ï¼Œå®ƒä»¬å¯ä»¥å¸®åŠ©ä½ æ›´å¥½åœ°ç¡®å®šå½“å‰è¿è¡Œç¯å¢ƒï¼Œè®©ä½ çš„ä»£ç èƒ½å¤Ÿæ®æ­¤è¿›è¡Œé€‚é…ã€‚

<Cards>
  <Card title="Integrated With `cmdr`" href="#integrated-with-cmdr" />
</Cards>

## Features

- `is.State(which) bool`: the universal detector entry - via `RegisterStateGetter(state string, getter func() bool)` to add your own ones. _Since v0.5.11_
- `is.Env()` holds a global struct for CLI app basic states, such as: verbose/quiet/debug/trace....
  - `DebugMode`/`DebugLevel`, `TraceMode`/`TraceLevel`, `ColorMode`, ...
- `is.InDebugging() bool`, `is.InTesting() bool`, and `is.InTracing() bool`, ....
- `is.DebugBuild() bool`.
- `is.K8sBuild() bool`, `is.DockerBuild() bool`, ....
- `is.ColoredTty() bool`, ....
- `is.Color()` to get an indexer for the functions in our term/color subpackage, ...
- Terminal Colorizer, Detector, unescape tools.
- stringtool: `RandomStringPure`, case-converters ...
- basics: closable, closer, signals.
  - easier `Press any key to exit...` prompt: `is.Signals().Catch()`
- exec: Run, RunWithOutput, Sudo, ...
- go1.23.7+ required since v0.7.0
- ~~go 1.22.7+ required~~

To using environment detecting utilities better and smoother, some terminal (and stringtool, basics) tools are bundled together.

Since v0.6.0, `is.InDebugging()` checks if the running process' parent is `dlv`.
The old `DebugMode` and `DebugBuild` are still work:

- `InDebugging`: checks this process is being debugged by `dlv`.
- `DebugBuild`: `-tags=delve` is set at building.
- `DebugMode`: `--debug` is specified at command line.

Since v0.8.27, `basics.Signals().Catcher().WaitFor()` wants `ctx` param passed in.

## åˆ†ç±»

### åŸºç¡€ç¯å¢ƒ

- `InDebugging`: checks this process is being debugged by `dlv`.
- `DebugBuild`: `-tags=delve` is set at building.
- `DebugMode`: `--debug` is specified at command line.
- `is.InTracing` / InTestingT
- `is.InTesting` / InTestingT
- `is.InDevelopingTime`
- `is.InVscodeTerminal`
- `is.InK8s`
- `is.InIstio`
- `is.InDocker` / InDockerEnvSimple

- Build (need `-tags=xx`)

  - `is.K8sBuild`: need `-tags=k8s` present
  - `is.IstioBuild`: need `-tags=istio` present
  - `is.DockerBuild`: need `-tags=docker` present
  - `is.VerboseBuild`: need `-tags=verbose` present
  - `is.DebugBuild`: need `-tags=delve` present
  - `buildtags.IsBuildTagExists`

### States / Env

- VerboseModeEnabled
- GetVerboseLevel / SetVerboseMode / SetVerboseLevel
- QuietModeEnabled
- GetQuietLevel / SetQuietMode / SetQuietLevel
- NoColorMode
- GetNoColorLevel / SetNoColorMode / SetNoColorLevel
- DebugMode
- GetDebugLevel / SetDebugMode / SetDebugLevel
- Tracing
- TraceMode
- GetTraceLevel / SetTraceMode / SetTraceLevel

### Terminal / Tty

- is.Terminal(file)
- is.TerminalFd(fd)
- is.Tty(wr)
- is.ColoredTty(wr)
- is.AnsiEscaped(s) (~~IsTtyEscaped(s)~~)
- StripEscapes(s)
- ReadPassword
- GetTtySize
- is.GetTtySizeByName(filename) (cols,rows,err)
- is.GetTtySizeByFile(file) (cols,rows,err)
- is.GetTtySizeByFd(fd) (cols,rows,err)
- StartupByDoubleClick() bool

### Basics

- closers
  - `Peripheral`, `Closable`, Closer
  - RegisterClosable
  - RegisterClosers
  - RegisterCloseFns
- `is.Signals().Catcher()`
- is.FileExists(filepath)
- is.ToBool, StringToBool

### utilities

- `dir` subpackage
- `exec` subpackage
- `term/color` subpackage
  - escaping tools: GetCPT()/GetCPTC()/GetCPTNC()
  - Highlight, Dimf, Text, Dim, ToDim, ToHighlight, ToColor, ...

## Usages

```go
package main

import (
    "context"
    "fmt"
    "log/slog"
    "os"
    "sync"
    "time"

    "github.com/hedzr/is"
    "github.com/hedzr/is/basics"
    "github.com/hedzr/is/term/color"
)

func main() {
    // defer basics.Close() // uncomment if not using Catcher.WaitFor and/or cmdr.v2

    is.RegisterStateGetter("custom", func() bool { return is.InVscodeTerminal() })

    println(is.InTesting())
    println(is.State("in-testing"))
    println(is.State("custom")) // detects a state with custom detector
    println(is.Env().GetDebugLevel())
    if is.InDebugMode() {
        slog.SetDefault(slog.New(slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{AddSource: true, Level: slog.LevelDebug})))
    }

    // or:
    //    is.Color().GetColorTranslator().Translate("<b>bold</b>")
    fmt.Printf("%v", color.GetCPT().Translate(`<code>code</code> | <kbd>CTRL</kbd>
        <b>bold / strong / em</b>
        <i>italic / cite</i>
        <u>underline</u>
        <mark>inverse mark</mark>
        <del>strike / del </del>
        <font color="green">green text</font>
`, color.FgDefault))

    var cancelled int32
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()

    catcher := is.Signals().Catch()
    catcher.
        WithPrompt("Press CTRL-C to quit...").
        // WithOnLoopFunc(dbStarter, cacheStarter, mqStarter).
        WithPeripherals(&dbMgr{}).
        WithOnSignalCaught(func(ctx context.Context, sig os.Signal, wg *sync.WaitGroup) {
            println()
            slog.Info("signal caught", "sig", sig)
            cancel() // cancel user's loop, see Wait(...)
        }).
        WaitFor(ctx, func(ctx context.Context, closer func()) {
            slog.Debug("entering looper's loop...")
            defer close() // notify catcher we want to shutdown
            // to terminate this app after a while automatically:
            time.Sleep(10 * time.Second)

            if atomic.CompareAndSwapInt32(&cancelled, 0, 1) {
                is.PressAnyKeyToContinue(os.Stdin)
            }
        })
}
```

Result is similar with:

![image-20240113071930661](/images/is/image-20240113071930661.png)

NOTE that `is.Signals().Catch()` will produce a prompt and enter a infinite loop to wait for user's keystroke pressed.

### Build Tags

Some functions want special buildtags presented. These are including:

- `verbose`: See VerboseBuild, ...
- `delve`: See DebugBuild, ...
- `k8s`: See K8sBuild
- `istio`: See IstioBuild
- `docker`: See DockerBuild
- ...
- `buildtags.IsBuildTagExists(tag) bool`

### Colorizes

The test codes:

```go
import "github.com/hedzr/is/term/color"

func TestGetCPT(t *testing.T) {
  t.Logf("%v", color.GetCPT().Translate(`<code>code</code> | <kbd>CTRL</kbd>
    <b>bold / strong / em</b>
    <i>italic / cite</i>
    <u>underline</u>
    <mark>inverse mark</mark>
    <del>strike / del </del>
    <font color="green">green text</font>
    `, color.FgDefault))
}
```

Result:

![image-20231107100150520](/images/is/image-20231107100150520.png)

And more:

```go
func TestStripLeftTabs(t *testing.T) {
t.Logf("%v", color.StripLeftTabs(`

        <code>code</code>
    NC Cool
     But it's tight.
      Hold On!
    Hurry Up.
    `))
}

func TestStripHTMLTags(t *testing.T) {
t.Logf("%v", color.StripHTMLTags(`

        <code>code</code>
    NC Cool
     But it's tight.
      Hold On!
    Hurry Up.
    `))
}
```

### `Cursor`

ä» v0.8+ å¼€å§‹ï¼Œä¸€ä¸ªæ–°çš„ `color.Cursor` å¯¹è±¡å¯ä»¥è¢« `color.New()` åˆ›å»ºï¼Œå¹¶æ”¯æŒç”¨æµå¼è°ƒç”¨æ–¹å¼æ¥å®Œæˆå½©è‰²åŒ–æ–‡å­—ã€‚

è¾ƒä¸ºå®Œæ•´çš„ç¤ºä¾‹å¦‚ä¸‹ï¼š

Since v0.8+, A new `color.Cursor` object can be initialized by `color.New()`, which support format the colorful text with streaming calls, for console/tty.

The examples are:

```go

func ExampleNew() {
	// start a color text builder
	var c = color.New()

	// specially for running on remote ci server
	if states.Env().IsNoColorMode() {
		states.Env().SetNoColorMode(true)
	}

	// paint and get the result (with ansi-color-seq ready)
	var result = c.Println().
		Color16(color.FgRed).
		Printf("hello, %s.", "world").Println().
		SavePos().
		Println("x").
		Color16(color.FgGreen).Printf("hello, %s.\n", "world").
		Color256(160).Printf("[160] hello, %s.\n", "world").
		Color256(161).Printf("[161] hello, %s.\n", "world").
		Color256(162).Printf("[162] hello, %s.\n", "world").
		Color256(163).Printf("[163] hello, %s.\n", "world").
		Color256(164).Printf("[164] hello, %s.\n", "world").
		Color256(165).Printf("[165] hello, %s.\n", "world").
		Up(3).Echo(" ERASED ").
		RGB(211, 211, 33).Printf("[16m] hello, %s.", "world").
		Println().
		RestorePos().
		Println("z").
		Down(8).
		Println("DONE").
		Build()

		// and render the result
	fmt.Println(result)

	// For most of ttys, the output looks like:
	//
	// [31mhello, world.[0m
	// [sx
	// [32mhello, world.
	// [38;5;160m[160] hello, world.
	// [38;5;161m[161] hello, world.
	// [38;5;162m[162] hello, world.
	// [38;5;163m[163] hello, world.
	// [38;5;164m[164] hello, world.
	// [38;5;165m[165] hello, world.
	// [0m[3A ERASED [38;2;211;211;33m[16m] hello, world.
	// [uz
	// [8BDONE
}

func ExampleCursor_Color16() {
	// another colorful builfer
	var c = color.New()
	fmt.Println(c.Color16(color.FgRed).
		Printf("hello, %s.", "world").Println().Build())
	// Output: [31mhello, world.[0m
}

func ExampleCursor_Color() {
	// another colorful builfer
	var c = color.New()
	fmt.Println(c.Color(color.FgRed, "hello, %s.", "world").Build())
	// Output: [31mhello, world.[0m
}

func ExampleCursor_Bg() {
	// another colorful builfer
	var c = color.New()
	fmt.Println(c.Bg(color.BgRed, "hello, %s.", "world").Build())
	// Output: [41mhello, world.[0m
}

func ExampleCursor_Effect() {
	// another colorful builfer
	var c = color.New()
	fmt.Println(c.Effect(color.BgDim, "hello, %s.", "world").Build())
	// Output: [2mhello, world.[0m
}

func ExampleCursor_Color256() {
	// another colorful builfer
	var c = color.New()
	fmt.Print(c.
		Color256(163).Printf("[163] hello, %s.\n", "world").
		Color256(164).Printf("[164] hello, %s.\n", "world").
		Color256(165).Printf("[165] hello, %s.\n", "world").
		Build())
	// Output:
	// [38;5;163m[163] hello, world.
	// [38;5;164m[164] hello, world.
	// [38;5;165m[165] hello, world.
}

func ExampleCursor_RGB() {
	// another colorful builfer
	var c = color.New()
	fmt.Print(c.
		RGB(211, 211, 33).Printf("[16m] hello, %s.\n", "world").
		BgRGB(211, 211, 33).Printf("[16m] hello, %s.\n", "world").
		Build())
	// Output:
	// [38;2;211;211;33m[16m] hello, world.
	// [48;2;211;211;33m[16m] hello, world.
}

func ExampleCursor_EDim() {
	// another colorful builfer
	var c = color.New()
	fmt.Print(c. // Color16(color.FgRed).
			EDim("[DIM] hello, %s.\n", "world").String())
	// Output:
	// [2m[DIM] hello, world.
	// [0m
}

func ExampleCursor_Black() {
	// another colorful builfer
	var c = color.New()
	fmt.Print(c. // Color16(color.FgRed).
			Black("[BLACK] hello, %s.\n", "world").String())
	// Output:
	// [30m[BLACK] hello, world.
	// [0m
}

func ExampleCursor_BgBlack() {
	// another colorful builfer
	var c = color.New()
	fmt.Print(c. // Color16(color.FgRed).
			BgBlack("[BGBLACK] hello, %s.\n", "world").String())
	// Output:
	// [40m[BGBLACK] hello, world.
	// [0m
}

func ExampleCursor_Translate() {
	// another colorful builfer
	var c = color.New()
	fmt.Print(c. // Color16(color.FgRed).
			Translate(`<code>code</code> | <kbd>CTRL</kbd>
		<b>bold / strong / em</b>
		<i>italic / cite</i>
		<u>underline</u>
		<mark>inverse mark</mark>
		<del>strike / del </del>
		<font color="green">green text</font>
		`).String())
	// Output:
	// [51;1mcode[0m[39m | [51;1mCTRL[0m[39m
	//		[1mbold / strong / em[0m[39m
	//		[3mitalic / cite[0m[39m
	//		[4munderline[0m[39m
	//		[7minverse mark[0m[39m
	//		[9mstrike / del [0m[39m
	//		[32mgreen text[0m[39m
}

func ExampleCursor_StripLeftTabsColorful() {
	// another colorful builfer
	var c = color.New()
	fmt.Print(c. // Color16(color.FgRed).
			StripLeftTabsColorful(`
		<code>code</code> | <kbd>CTRL</kbd>
		<b>bold / strong / em</b>
		<i>italic / cite</i>
		<u>underline</u>
		<mark>inverse mark</mark>
		<del>strike / del </del>
		<font color="green">green text</font>
		`).String())
	// Output:
	// [51;1mcode[0m[0m | [51;1mCTRL[0m[0m
	// [1mbold / strong / em[0m[0m
	// [3mitalic / cite[0m[0m
	// [4munderline[0m[0m
	// [7minverse mark[0m[0m
	// [9mstrike / del [0m[0m
	// [32mgreen text[0m[0m
}
```

## ä¸ `cmdr` ç›¸é›†æˆ [#integrated-with-cmdr]

### `Closers`

`is` æä¾›ä¸€ä¸ªå­åŒ… `closers` æ¥æŠ½è±¡ä½ çš„åŸºç¡€è®¾æ–½ã€‚

```go
type Peripheral interface {
  Close()
}
```

ä¸€ä¸ªåŸºç¡€è®¾æ–½æ„å‘³ç€ä¸€ä¸ªéœ€è¦åœ¨åº”ç”¨ç¨‹åºç»“æŸå‰å®æ–½å…¶å…³é—­æ“ä½œçš„å¯¹è±¡ï¼Œå¯ä»¥æ˜¯å¤–éƒ¨èµ„æºå¦‚æ•°æ®åº“è¿æ¥ç­‰ï¼Œä¹Ÿå¯ä»¥æ˜¯ä¸€ä¸ªæ–‡ä»¶å¥æŸ„ã€‚

åœ¨ä½ çš„ app ä¸­ï¼Œå¯ä»¥ä½¿ç”¨ `RegisterPeripheral` æ³¨å†Œä¸€ä¸ªåŸºç¡€è®¾æ–½ï¼Œå¹¶æä¾› defer è°ƒç”¨ä»¥ä¾¿å…³é—­æ‰€æœ‰è¿™äº›å¯¹è±¡ã€‚

```go
func main() {
  defer is.Closers().Close()

  // ...RegisterPeripheral yours
}
```

The `Closers()` collects all closable objects and allow shutting down them at once.

```go
package main

import (
    "os"

    "github.com/hedzr/is/basics"
)

type redisHub struct{}

func (s *redisHub) Close() {
    // close the connections to redis servers
    println("redis connections closed")
}

func main() {
    defer basics.Close()

    tmpFile, _ := os.CreateTemp(os.TempDir(), "1*.log")
    basics.RegisterClosers(tmpFile)

    basics.RegisterCloseFn(func() {
        // do some shutdown operations here
        println("close single functor")
    })

    basics.RegisterPeripheral(&redisHub{})
}
```

#### with `cmdr`

`cmdr` åœ¨å®ƒçš„å·¥ä½œæµç¨‹ä¸­ä¼šè‡ªåŠ¨æ‰§è¡Œç›¸ä¼¼çš„è°ƒç”¨ä»¥ä¾¿å…³é—­å·²ç»æ³¨å†Œçš„åŸºç¡€è®¾æ–½ï¼Œå› æ­¤ `is` + `cmdr` å¯ä»¥æ›´æ— ç¼åœ°ååŒå·¥ä½œã€‚

å…·ä½“å®æ–½å¯ä»¥å‚è€ƒï¼š

<Cards>
  <Card title="Auto-close closers" href="../auto-close-closers" />
</Cards>

### `Signals`

`Signals()` could catch OS signals and entering a infinite loop.

`is.Signals()` èƒ½å¤Ÿæ‹¦æˆª POSIX ä¿¡å·å¹¶å›è°ƒä½ çš„å“åº”å‡½æ•°ã€‚

For example, a tcp server could be:

```go
package main

import (
    "context"
    "os"
    "sync"

    "github.com/hedzr/go-socketlib/net"
    "github.com/hedzr/is"
    logz "github.com/hedzr/logg/slog"
)

func main() {
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()

    logger := logz.New("new-dns")
    server := net.NewServer(":7099",
        net.WithServerOnListening(func(ss net.Server, l stdnet.Listener) {
            go runClient(ctx, ss, l)
        }),
        net.WithServerLogger(logger.WithSkip(1)),
    )
    defer server.Close()

    // make a catcher so that it can catch ths signals,
    catcher := is.Signals().Catch()
    catcher.
        // WithVerboseFn(func(msg string, args ...any) {
        //     logz.WithSkip(2).Verbose(fmt.Sprintf("[verbose] %s", fmt.Sprintf(msg, args...)))
        // }).
        WithOnSignalCaught(func(ctx context.Context, sig os.Signal, wg *sync.WaitGroup) {
            println()
            // logz.Debug("signal caught", "sig", sig)
            if err := server.Shutdown(); err != nil {
                logz.Error("server shutdown error", "err", err)
            }
            cancel()
        }).
        WaitFor(ctx, func(ctx context.Context, closer func()) {
            logz.Debug("entering looper's loop...")

            server.WithOnShutdown(func(err error, ss net.Server) { closer() })
            err := server.ListenAndServe(ctx, nil)
            if err != nil {
                logz.Fatal("server serve failed", "err", err)
            }
        })
}

func runClient(ctx context.Context, ss net.Server, l stdnet.Listener) {
    c := net.NewClient()

    if err := c.Dial("tcp", ":7099"); err != nil {
        logz.Fatal("connecting to server failed", "err", err, "server-endpoint", ":7099")
    }
    logz.Info("[client] connected", "server.addr", c.RemoteAddr())
    c.RunDemo(ctx)
}
```

#### `WaitFor()`

åœ¨ `WaitFor()` å›è°ƒå‡½æ•°ä½“å†…ï¼Œä½ å¯ä»¥å¯åŠ¨ä½ çš„æœåŠ¡ã€‚å®ƒä»¬ä¸å¿…åœ¨ go routine ä¸­è¢«å¯åŠ¨ï¼Œè€Œæ˜¯å¯ä»¥ç›´æ¥æ”¾åœ¨ `WaitFor()` å›è°ƒå‡½æ•°ä½“å†…ã€‚è¿™æ˜¯å› ä¸º `Catcher()` å°†åœ¨ä¸€ä¸ª go routine ä¸­è¿è¡Œä½ çš„å›è°ƒå‡½æ•°ã€‚

æ‰€ä»¥å¯¹äº http server æ¥è¯´ï¼Œä¸‹é¢çš„åšæ³•æ˜¯æ­£ç¡®çš„ï¼š

```go
  WaitFor(ctx, func(ctx context.Context, closer func()) {
    logz.Debug("entering looper's loop...")

    server.WithOnShutdown(func(err error, ss net.Server) { closer() })
    err := server.ListenAndServe(ctx, nil)
    if err != nil {
      logz.Fatal("server serve failed", "err", err)
    }
  })
```

å‡è®¾ä½ åœ¨å…¶ä»–åœ°æ–¹å¯åŠ¨äº†æœåŠ¡ï¼Œå¹¶ä¸”é€šè¿‡ ctx cancel() æ¥ç®¡ç†é‚£äº›æœåŠ¡çš„ç”Ÿå­˜å‘¨æœŸï¼Œé‚£ä¹ˆ WaitFor å›è°ƒå‡½æ•°å¯ä»¥è¿™ä¹ˆå†™ï¼š

```go
  WaitFor(ctx, func(ctx context.Context, closer func()) {
    defer closer()
    for {
      select {
      case <-ticker.C:
        wakeupForTask();
      case <-ctx.Done():
        return
      }
    }
  })
```

å½“å…¨å±€çš„ cancellable ctx çš„ `cancel()` å‡½æ•°è¢«è°ƒç”¨æ—¶ï¼Œä½ çš„å…¶ä»–æœåŠ¡å°†ä¼šä¾¦å¬ ctx.Done() ä¿¡å·å¹¶ Shutdownï¼Œè€Œä¸Šé¢çš„ `WaitFor()` å›è°ƒå‡½æ•°ä½“ä¹Ÿä¼šç»“æŸè‡ªå·±ï¼Œå¹¶è°ƒç”¨ closer() æ¥æ¸…ç† `Catcher()` è‡ªèº«ã€‚

#### Howto terminate myself after a while

æœ‰æ—¶å€™æˆ‘ä»¬å¯èƒ½éœ€è¦æç¤ºç”¨æˆ·ç­‰å¾… 10 ç§’é’Ÿï¼ˆ10sï¼‰ç„¶åè‡ªåŠ¨ç»“æŸç­‰å¾…å¹¶é€€å‡ºç¨‹åºã€‚
è¿™ä¸ªéœ€æ±‚å¯ä»¥ç”¨ `Catch()` æ¥å®ç°ï¼š

```go
	ctx, cancel := context.WithCancel(context.Background())
  defer cancel()
	catcher := is.Signals().Catch()
	catcher.
		WithPrompt("Press CTRL-C to quit...").
		WithOnSignalCaught(func(ctx context.Contextsig os.Signal, wg *sync.WaitGroup) {
			println()
			// slog.Info("signal caught", "sig", sig)
			cancel() // cancel user's loop, see Wait(...)
		}).
		WaitFor(ctx, func(ctx context.Context, closer func()) {
			// slog.Debug("entering looper's loop...")
			go func() {
				// to terminate this app after a while automatically:
				time.Sleep(10 * time.Second)
				// closer will send a os.SigInt to cause `WithOnSignalCaught`
        // calling `cancel()`
				closer()
			}()
			<-ctx.Done() // waiting until any os signal caught
		})
```

å°½ç®¡è¿™ä¸ªæ–¹æ¡ˆçœ‹èµ·æ¥ç¨å¾®æœ‰äº›ç¬¨é‡ç¹å¤ï¼Œä½†äº‹å®ä¸Šå¹¶éå¦‚æ­¤ï¼Œå®ƒå·¥ä½œèµ·æ¥ç›¸å½“è½»å·§ï¼Œæ²¡æœ‰ä»»ä½•äº’é”æœºåˆ¶å¯¼è‡´è¿Ÿæ»ã€‚

å½“ç„¶ï¼Œå¦‚æœæ˜¯å•çº¯åœ°éœ€è¦ä¸€ä¸ªç®€å•åœ°â€œPress any key to continue...â€ï¼Œå¯ä»¥ä½¿ç”¨ `is.PressAnyKeyToContinue(in io.Reader, msg ...string) (input string)` æˆ–è€… `is.PressEnterToContinue(in io.Reader, msg ...string) (input string)` æ¥è¾¾æˆç›®çš„ã€‚å®ƒä»¬ä»…ä»…ä½¿ç”¨ `bufio.Fscanf()` æˆ–è€… `bufio.NewReader(in).ReadBytes('\n')`ï¼Œä¸€å®šæ¯” `Catch()` æ–¹æ¡ˆè½»å·§â€”â€”é™¤éä½ ä¹ŸåŒæ—¶éœ€è¦å¯¹ `os.Signal` è¿›è¡Œæ•ä¿˜ã€‚ä½ åº”è¯¥æä¾› `os.Stdin` ä½œä¸ºå…¶å‚æ•°ã€‚

### é¢å¤–çš„è¯é¢˜

<Cards>
  <Card title="Chapter: Using Store" href="../using-store/" />
  <Card title="`hedzr/is` on Github" href="https://github.com/hedzr/is" />
  <Card title="Manual of `hedzr/store`" href="/docs/store/" />
  <Card title="`hedzr/store` on Github" href="https://github.com/hedzr/store" />
</Cards>

:end:
