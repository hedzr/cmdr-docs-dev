---
title: 命令：重定向
description: Redirect To...
---

## 重定向某命令到另一目的地

~~`.SetRedirectTo(subcmd)` 为根命令提供一个重定向目的地~~。

从 v2.1.19 开始，`.SetRedirectTo(subcmd)` 不仅仅为根命令提供一个重定向目的地，也支持任何子命令的重定向。

`重定向到另一命令` 作用于根命令时，可以让命令行输入 `app` 等价于输入了 `app a b c`，这对于有的情形可能是有用的。

想象一下 `pnpm` 这样的包管理器命令，`pnpm dev` 实际上等价于 `pnpm run dev` 子命令，都是去运行 `package.json` 的 `scripts` 节里的 `dev` 条目所定义的命令行。

> **TODO**  
> cmdr.v2 有设想为 RedirectTo 加上 fallback: bool 的子特性。
>
> 但这一设想尚未定型，也没有纳入计划表。

### 定义

#### 对于根命令

你需要调用到 RootCommand 的 `*CmdS.SetRedirectTo(dottedCmdPath)` 接口。达到这一目的的途径可能有多种，下面是一个示例，

```go title="redirect-to-subcmd/main.go"
func main() {
	app := cmdr.Create(appName, version, author, desc).With(func(app cli.App) {
		// [!code highlight:7]
		// redirect root commands into "wrong" subcmd for testing.
		//
		// For a dad command such as "server" command, it
		// would translate `app start|stop` -> `app server start|stop`.
		app.WithRootCommand(func(root *cli.RootCommand) {
			root.SetRedirectTo("wrong")
		})
	}).WithAdders(cmd.Commands...).Build()

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	if err := app.Run(ctx); err != nil {
		logz.ErrorContext(ctx, "Application Error:", "err", err) // stacktrace if in debug mode/build
		os.Exit(app.SuggestRetCode())
	} else if rc := app.SuggestRetCode(); rc != 0 {
		os.Exit(rc)
	}
}
```

完整的源代码可以参考 [examples/redirect-to-subcmd](https://github.com/hedzr/cmdr/blob/master/examples/redirect-to-subcmd/)。

在范例中，`WithAdders()` 将会为 app 添加两套子命令：`jump to` 以及 `wrong`。这是标准的 `examples/cmd/` 子包用于演示目的的基础设施。

而 `With(func(app cli.App){...})` 闭包则提供一个流式调用中操作 app 对象的机会。
在这里，`app.WithRootCommand(...)` 可以用于操作 `SetRedirectTo` 接口函数。

现在，运行 `app` 的效果就和 `app wrong` 相同。

#### 可以有多种途径达到目的

为了达到完成到 `RootCommand.SetRedirectTo` 的调用，可以有多种途径。例如下面这一种：

```go
func prepareApp(commands ...cli.CmdAdder) cli.App {
	return loaders.Create(
		appName, version, author, desc,
	).
		// importing devmode package and run its init():
		With(func(app cli.App) {
			logz.Debug("in dev mode?", "mode", devmode.InDevelopmentMode())
			app.RootBuilder(func(parent cli.CommandBuilder) {
				parent.RedirectTo("new")
			})
			// app.WithRootCommand(func(root *cli.RootCommand) {
			// 	root.SetRedirectTo("new")
			// })
		}).
		WithBuilders(
		// examples.AddHeadLikeFlagWithoutCmd, // add a `--line` option, feel free to remove it.
		).
		WithAdders(commands...).
		Build()
}
```

#### 对于子命令（Since V2.1.19）

对于子命令的重定向，你可以使用 `CommandBuilder.RedirectTo(dottedCmdPath)` 接口。下面是一个示例：

```go
package cmd

import (
	"github.com/hedzr/cmdr/v2/cli"
	logz "github.com/hedzr/logg/slog"

	"github.com/hedzr/cmdr-cli/cli/cmdr/internal/core"
)

type initCmd struct{}

func (*initCmd) Add(app cli.App) {
	coreTool := core.New()
	logz.Verbose("initCmd")

	app.Cmd("init", "i", "in").
		Description("initial a cmdr-based app").
		// Group("Test").
		// TailPlaceHolders("[text1, text2, ...]").
		Examples(`

		$ {{.AppName}} init
		  create a new cmdr cli app with default name 'myapp'
		$ {{.AppName}} init myapp
		  create a new cmdr cli app with your name
		`).
		RedirectTo("new").
		OnAction(coreTool.New).
		With(func(b cli.CommandBuilder) {
		})
}
```

这个示例来自 `cmdr-cli` 工具的 `init` 子命令源代码。

同样地，使用 `dottedCmdPath` 可以重定向到多级子命令，例如 `jump.to`。

### 多级命令

如果想要重定向到多级子命令，可以使用 `dottedPath`。例如跳转到 `jump to` 子命令，可以使用 `SetRedirectTo("jump.to")` 来达成。

### 运行时

上面的示例程序的运行时效果如同这样：

```bash
$ go run ./examples/redirect-to-subcmd
the duration is: 0s
22:57:12.597014+08:00| [ERR] Application Error:                   err="[io: read/write on closed pipe | something's wrong | permission denied]" ./examples/redirect-to-subcmd/main.go:38 main.main
$
```

返回的 Application Error 显示出根命令已经正确转向到了 “wrong” 子命令。

此时根命令默认功能就不再是显示帮助屏了，为了显示帮助屏，你需要显式地 `-h`/`--help`。

### 帮助屏中的效果

以下截图取自 [`cmdr-cli`](httpsL//github.com/hedzr/cmdr-cli) 工具（即将发布）。

#### Rootcmd

![image-20250601120911889](/images/cmdr/v2/g37-cmd-redirect-to/image-20250601120911889.png)

#### Subcmd

![image-20250601122307546](/images/cmdr/v2/g37-cmd-redirect-to/image-20250601122307546.png)

<include>../../headless/cmdr-guide-concepts-command.mdx</include>
